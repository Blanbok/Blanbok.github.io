    <!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="OComme">
		<meta name="description" content="Some personal talk about development is about everyday thinking">
		<meta name="generator" content="Hugo 0.37" />
		<title>Objective-c Coding Standard &middot; OComme&#39;s blog</title>
		<link rel="shortcut icon" href="https://ocomme.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://ocomme.github.io/css/style.css">
		<link rel="stylesheet" href="https://ocomme.github.io/css/highlight.css">
		

		
		<link rel="stylesheet" href="https://ocomme.github.io/css/font-awesome.min.css">
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://ocomme.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://ocomme.github.io/post'>Archive</a>
	<a href='https://ocomme.github.io/tags'>Tags</a>
	<a href='https://ocomme.github.io/about'>Novel</a>

	

	
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Objective-c Coding Standard
                    </h1>
                    <h2 class="headline">
                    Aug 12, 2017 17:33
                    · 8275 words
                    · 17 minutes read
                      <span class="tags">
                      
                      
                          
                              <a href="https://ocomme.github.io/tags/ios-development">iOS-Development</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<!--[TOC]
-->

<p>此次规范从当前的开发现状（风格各异）出发，奠基于当前的编码习惯，旨在规范大家的编程行为。
待到下次开会的时候，仍需依据自己的习惯，提出针对性的意见。后期将参考此次会上的意见进行修订。</p>

<blockquote>
<p>最近大佬要规范下团队里的编码规范，作为狗腿子的咱自然是要响应下号召咯&hellip;顺带的自己也想把规范定下来，后面一步步的修订，方便代码更新迭代。
还是想着能让自己代码更加的简洁、明了、具有表达力的😁
希望下次谁谁看代码的时候，不用特意去对照界面就能了解这是个做什么的。</p>
</blockquote>

<hr />

<h1 id="一-资料参考">一- 资料参考</h1>

<p>我们所写的代码主要是为了阅读，其次才是被机器执行。所以我们要写：</p>

<ul>
<li>让别人能读懂的代码</li>
<li>可扩展的代码</li>
<li>可测试的代码(代码应该具备可测试性，对没有可测试性的代码写测试，是浪费生命的表现)</li>
</ul>

<h2 id="1-编程原则">1、编程原则</h2>

<p>许多刚步入编程之路的人，总喜欢鼓吹各种各样的“原则”</p>

<h3 id="1-rc原则">(1) RC原则</h3>

<blockquote>
<p>可读性高(Readable)
防止命名冲突(Conflict Name prevention)</p>
</blockquote>

<h3 id="2-tedc原则">(2) TEDC原则</h3>

<blockquote>
<p>简洁(Terse)
具有表达力(Expressive)
只做一件事(Do one thing)</p>
</blockquote>

<h3 id="3-dry原则">(3) DRY原则</h3>

<blockquote>
<p>Don&rsquo;t Repeat Yourself</p>
</blockquote>

<h3 id="4-kiss原则">(4) KISS原则</h3>

<blockquote>
<p>Keep it Simple and Stupid</p>
</blockquote>

<h3 id="总结">总结</h3>

<p>许多刚步入编程门槛的程序员，总喜欢泛谈编程原则，将这些奉为教条或者秘方，觉得这些原则就是编程的捷径，能够直达编程之巅。</p>

<p>实际如此吗？很明显不是的，若真遵守几个原则就可以成为一个合格的程序员，那程序员岂不是太不值钱啦！(虽然事实就是如此😦)</p>

<p>所谓原则，更多的是供我们参考的一个经典思路，以供我们打开脑洞的。（先摸摸看你的脑袋能开多大的洞😄）</p>

<p>从来都没有“万金油”的代码，要想进行某项优化，则必会有相应的风险。</p>

<p>而我们在实际编程中所要积累的经验，正是对这些原则的取舍。</p>

<ul>
<li>通过牺牲掉某些自己用不上的因素来获取代码的优化，这才是我们在前期编程中所需要思考的。</li>
<li>完成对多项原则的协调，达到我们能完善的最好地步，这就是我们中期的目标了。</li>
<li>通过合理的架构来包容，完善代码，这大概是我们后期需要达到的目标吧。（Maybe）</li>
</ul>

<h2 id="2-命名方法">2、命名方法</h2>

<h3 id="1-匈牙利命名">(1) 匈牙利命名：</h3>

<p>开头字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，要求单词第一个字母大写。</p>

<pre><code>int iMyAge; “i”是int类型的缩写； 
char cMyName[10]; “c”是char类型的缩写； 
float fManHeight; “f”是float类型的缩写；
</code></pre>

<p><span id=named_02></span></p>

<h3 id="2-驼峰式命名法">(2) 驼峰式命名法</h3>

<p>又叫小驼峰式命名法。
第一个单词首字母小写，后面其他单词首字母大写。</p>

<pre><code>int myAge; 
char myName[10]; 
float manHeight;
</code></pre>

<p><span id=named_03></span></p>

<h3 id="3-帕斯卡命名法">(3) 帕斯卡命名法</h3>

<p>又叫大驼峰式命名法。
每个单词的第一个字母都大写。</p>

<pre><code>int MyAge; 
char MyName[10]; 
float ManHeight;
</code></pre>

<p><span id=named_04></span></p>

<h3 id="4-下划线命名法">(4) 下划线命名法</h3>

<p>在命名中添加下划线用以标识
一般Object-C中建议我们在命名前加<code>_</code>，用以区分成员变量与其它变量的</p>

<p>在命名后加<code>_</code>，通常用在宏命名中
其它情况下在，<code>_</code>添加在标识不同含义的单词块之间用以区分</p>

<pre><code>int _myage; 
char my_name[10]; 
__FILE__
</code></pre>

<h3 id="总结-1">总结</h3>

<p>Objective-C 的命名通常都比较长, 名称遵循<a href="#named_02">驼峰式命名法</a>. 一个好的命名标准很简单, 就是做到在开发者一看到名字时, 就能够懂得它的含义和使用方法.</p>

<p>有些时候这三者也会有起冲突的时候，怎么取舍呢？</p>

<p>借用官方的例子</p>

<p><span id=TEDC_01></span></p>

<ul>
<li>表达力 &gt; 简洁</li>
</ul>

<blockquote>
<p>尽可能具有表达力和简洁是好的，但是表达力不应该因为简洁而受到影响。</p>
</blockquote>

<table>
<thead>
<tr>
<th>代码</th>
<th>点评</th>
</tr>
</thead>

<tbody>
<tr>
<td>insertObject:atIndex:</td>
<td>Good</td>
</tr>

<tr>
<td>insert:at:</td>
<td>不清晰;要插⼊什么?“at”表⽰示什么?</td>
</tr>

<tr>
<td>removeObjectAtIndex:</td>
<td>Good</td>
</tr>

<tr>
<td>removeObject:</td>
<td>不错,因为⽅法是⽤用来移除作为参数的对象</td>
</tr>

<tr>
<td>remove:</td>
<td>不清晰;要移除什么?</td>
</tr>
</tbody>
</table>

<ul>
<li>清晰表达意思</li>
</ul>

<blockquote>
<p>一般来说，不要缩写事物的名称。把它们拼出来，即使它们很长:</p>
</blockquote>

<table>
<thead>
<tr>
<th>代码</th>
<th>点评</th>
</tr>
</thead>

<tbody>
<tr>
<td>destinationSelection</td>
<td>Good</td>
</tr>

<tr>
<td>destSel</td>
<td>不清晰</td>
</tr>

<tr>
<td>setBackgroundColor:</td>
<td>Good</td>
</tr>

<tr>
<td>setBkgdColor:</td>
<td>不清晰</td>
</tr>
</tbody>
</table>

<ul>
<li>避免歧义</li>
</ul>

<blockquote>
<p>避免API名称中的歧义，例如可以用多种方法解释的方法名</p>
</blockquote>

<table>
<thead>
<tr>
<th>代码</th>
<th>点评</th>
</tr>
</thead>

<tbody>
<tr>
<td>sendPort</td>
<td>它是发送端口还是返回?</td>
</tr>

<tr>
<td>displayName</td>
<td>它是在用户界面中显示一个名称还是返回接收者的标题?</td>
</tr>
</tbody>
</table>

<p>需要察看更多的规范，请前往<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH">官方文档</a></p>

<h1 id="二-命名规范">二- 命名规范</h1>

<h2 id="1-变量命名">1、变量命名</h2>

<h3 id="1-一般变量命名">(1) 一般变量命名</h3>

<p><span style="color:#F00">命名方式</span>：【小写类型前缀+<code>_</code>+介绍<a href="#named_02">小驼峰式</a>】的做法。【介绍尽量用自然语言表达自己的意思。】</p>

<p>于个人而言，变量名使用更多的是下划线加驼峰式的命名，尽量用自然语言命名自己的变量</p>

<pre><code>@property (nonnull,nonatomic,strong) UIImageView *imageView_head;
</code></pre>

<h3 id="2-模型内的属性命名">(2) 模型内的属性命名</h3>

<p><span style="color:#F00">命名方式</span>：<a href="#named_04">下划线命名</a></p>

<p>坚持<span style="color:#F00">一致性</span>的原则</p>

<p>当下后台属性命名方式：<a href="#named_04">下划线命名</a></p>

<p>对于用于解析后台数据的模型，应尽量保持与后台命名方式一致，最好能命名完全一致
对于用于处理本地数据的模型，也应保持与后台命名方式一致。</p>

<p><span style="color:#F00"><strong>即应保证具有某一共同功能的类型命名方式一致。</strong></span></p>

<h2 id="2-类命名">2、类命名</h2>

<p><span style="color:#F00">命名方式</span>：<a href="#named_03">大驼峰式命名法</a></p>

<p>对于一般的类，通常是使用大驼峰式的命名方式
类名的拼写方式一般采用<span style="color:#F00">[标识 + 模块名称+功能介绍+类型]</span></p>

<p><strong>标识</strong>用于区分其它第三方的类，一般为开发者或者开发公司的标识</p>

<p><strong>模块名称</strong>标识当前类在界面中所处模块名称</p>

<p><strong>功能介绍</strong>标识当前类在当前模块中的作用</p>

<p><strong>类型</strong>标识当前类的类型</p>

<p>其中最有争议的应该是<strong>模块名称</strong></p>

<table>
<thead>
<tr>
<th>位置</th>
<th>模块名称</th>
</tr>
</thead>

<tbody>
<tr>
<td>根控制器</td>
<td><code>Base</code></td>
</tr>

<tr>
<td>一般控制器</td>
<td>其根控制器的<strong>功能介绍</strong></td>
</tr>

<tr>
<td>一般视图</td>
<td>下一级响应者（父视图或是其所属的控制器）的<strong>功能介绍</strong></td>
</tr>

<tr>
<td>通用控制器（例如：登陆、注册或者是好几个<code>TabBar</code>分栏都会跳转的控制器）</td>
<td><code>public</code></td>
</tr>

<tr>
<td>通用视图（用于多个界面的视图）</td>
<td><code>public</code></td>
</tr>
</tbody>
</table>

<p>对控制器而言，模块名称即其根视图的<strong>功能介绍</strong>，若当前控制器即根控制器，则当前控制器的模块标识为<code>Base</code></p>

<p>对于类名，小子是按其在界面中的层次进行命名
对于处于界面第一级的视图 将它的 上一级功能名称的 拼接字段定为<code>Base</code></p>

<p>如<code>JYBaseHomeViewController</code> 表示首页的根控制器</p>

<p>其中</p>

<table>
<thead>
<tr>
<th>标识</th>
<th>上一级功能</th>
<th>功能介绍</th>
<th>类型</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>JY</code></td>
<td><code>Base</code></td>
<td><code>Home</code></td>
<td><code>ViewController</code></td>
</tr>
</tbody>
</table>

<h2 id="3-方法命名">3、方法命名</h2>

<p><span style="color:#F00">命名方式</span>：<a href="#named_02">小驼峰式命名法</a></p>

<p>方法名应遵守小驼峰原则，首字母小写，其他单词首字母大写,每个空格分割的名称以动词开头。</p>

<p>执行性的方法应该以动词开头，小写字母开头，返回性的方法应该以返回的内容开头，但之前不要加get。</p>

<p>方法名应具备以下特征</p>

<h3 id="1-表达力-简洁">(1) 表达力、简洁</h3>

<p>方法名应该是简洁并具有表达力，去除参数之后能形成可读的自然语言
当这二者需要取舍，应该<a href="#TEDC_01">着重强调表达力</a></p>

<p>例如：</p>

<p>使用<code>insertObject:(NSObject*)object  atIndex: (NSInteger)index</code></p>

<p>比<code>insert:(NSObject*)object at: (NSInteger)index</code>更合适</p>

<p>给它们去掉参数，变成自然语言即 “<span style="color:#F00">insert Object at Index</span>”对“<span style="color:#F00">insert at</span>”，孰优孰劣一目了然</p>

<h3 id="2-只做一件事">(2) 只做一件事</h3>

<p>当你无法为你的方法起一个准确的名称时，很可能你的方法不止做了一件事，违反了(Do one thing)。</p>

<p>特别是你想在方法名中加入：And，Or，If等词时</p>

<pre><code>- (void)RegisterUser:(User*) user SendEmail:(bool)sendEmail
{
    
}
</code></pre>

<p>此时，应该将执行不同逻辑操作的方法分开，构成两个不同的方法来执行</p>

<pre><code>- (void)RegisterUser:(User*)user
{

}

- (void)SendEmail:(User*)user
{

}
</code></pre>

<h3 id="3-尽可能少的参数">(3) 尽可能少的参数</h3>

<p>过多的参数让读者难以抓住代码的意图，同时过多的参数将会影响方法的稳定性。另外也预示着参数应该聚合为一个<code>Model</code></p>

<p>参数为<span style="color:#F00">1-2</span>个最合适</p>

<pre><code>- (void) RegisterUserName:(NSString*)userName Password:(NSString*) password Email:(NSString*) email  Phone:(NSString*)phone
{

}
</code></pre>

<p>此时参数超过3个，可以聚合成为一个模型，以增强可读性</p>

<pre><code>- (void) RegisterUser:(User*)user
{

}
</code></pre>

<h2 id="4-类别命名">4、类别命名</h2>

<p><span style="color:#F00">命名方式</span>：[类名+标识+扩展（<a href="#named_03">大驼峰式</a>）]</p>

<p>例：如果我们想要创建一个基于<code>NSString</code>的类别用于判断字符串类型，我们应该把类别放到名字是<code>NSString+JYJudgmentType</code>的文件里。</p>

<p><code>NSString</code>为要扩展的类名</p>

<p><code>JY</code>为标识</p>

<p><code>JudgmentType</code>为扩展的功能</p>

<h2 id="5-枚举的命名">5、枚举的命名</h2>

<p><span style="color:#F00">命名方式</span>：[标识+功能（<a href="#named_03">大驼峰式</a>）]</p>

<p>类型命名：[枚举名+特征]</p>

<p>下面我们列举一组用于判断字符串类型的枚举</p>

<pre><code>typedef NS_ENUM(NSInteger,JYJudgmentType){
    ///数字
    JYJudgmentTypeNumberCharacters             = 1,
    ///英文
    JYJudgmentTypeOrdinaryEnglishCharacters    = 1 &lt;&lt; 1,
    ///中文
    JYJudgmentTypeChineseCharacters            = 1 &lt;&lt; 2,
    ///电话
    JYJudgmentTypeMobile               = 1 &lt;&lt; 3,
    ///身份证
    JYJudgmentTypeIDCard               = 1 &lt;&lt; 4,
    ///银行卡
    JYJudgmentTypeBankCard             = 1 &lt;&lt; 5,
    ///邮箱
    JYJudgmentTypeEmail             = 1 &lt;&lt; 6,
};
</code></pre>

<p>我们就以<code>JYJudgmentTypeNumberCharacters</code>为例</p>

<p><code>JY</code>为标识，<code>JudgmentType</code>为该枚举的功能，<code>NumberCharacters</code>为当前类型的特征</p>

<h2 id="6-const常量">6、const常量</h2>

<p><span style="color:#F00">命名方式</span>：<a href="#named_03">大驼峰式</a></p>

<p>如果一定想要和其它变量区分开来，也可以给他一个标识</p>

<p>最明显的例子就是我们常用的<code>ReuseIdentifier</code></p>

<h2 id="7-宏命名">7、宏命名</h2>

<p><span style="color:#F00">命名方式</span>：<a href="#named_04">下划线命名</a>+全部字母大写
毕竟官方推荐命名方式</p>

<p>例如系统的宏<code>__FILE__</code>
我们也可以加上自己的标识用以和系统的宏区分开来<code>JY__FILE__</code></p>

<p>如果还要标识宏隶属于某一模块的话，还可以更进一步的加上模块的标识<code>JY__SQL__FILE__</code></p>

<h1 id="三-注释规范">三- 注释规范</h1>

<blockquote>
<p>关于注释，虽说是有很大一份人认为优秀的代码可以完全替代注释，然而在实际上，英语这么强的还是很少的🤦‍♂️。而且对我们来说，用尽可能低的标准来要求别人，项目可维护性。（唔，连中文注释都看不懂那就无解了😒）</p>
</blockquote>

<p>注释不用做得太夸张，由于开发中阅读注释大部分都只是为了关联或者了解某项功能，所以我们只需在关键点添加注释即可。</p>

<h2 id="1-类前的注释">1、类前的注释</h2>

<p>类的 <code>.h</code>文件中添加一段标识注释，用以解释当前类的用法</p>

<pre><code>/*
 创建人：（标识创建）
 创建版本：创建类的版本（了解功能在哪一个版本添加或重构）
 功能描述：介绍类的主要功能（让读者一目了然）
 --修改人：（标识功能修改者）
 修改版本：类修改的版本（哪个版本有进行修订）
 修改描述：（修订某一功能）
 ···：重复【修改人 — 修改版本 — 修改描述】三列的介绍。&quot;创建人&quot;在之后的修改过程中也将作为&quot;修改人&quot;
 */
</code></pre>

<h2 id="2-接口注释">2、接口注释</h2>

<p>推荐使用 <code>option</code>+<code>command</code>+<code>/</code>快捷注释命令
对类的接口处的属性、方法进行介绍</p>

<p>属性：</p>

<pre><code>/**
 介绍属性
 */
@property (nonnull,nonatomic,strong) NSObject *object;
</code></pre>

<p>方法：</p>

<pre><code>/**
 介绍方法功能

 @param obj 参数介绍
 */ 
- (void)RegisterUser:(User*)user;
</code></pre>

<h2 id="3-注释标记的使用">3、注释标记的使用</h2>

<p><code>OC</code>中是有很多的注释标记，就我所知的几个</p>

<pre><code>#pragma 编译指示

#warning 警告

//MARK: Method for handing memry managment

//TODO:通知更新，需要做的事

//FIXME: 你想要修改的bug[]()
</code></pre>

<p>而在诸多标记中，<code>#pragma mark</code>应该是使用最广的。</p>

<p>在学习编程的很长一段时间里，我几乎是将这个标记作为万金油的标记来使用的，不管是需要什么提示，都在使用这个标记来记录想要表达的意思。</p>

<p>虽说一直没出什么大问题，而且在表达意思上也不会有太多不明确的地方。</p>

<p>但出于规范，还是建议按照标准的语法来写出自己的注释。</p>

<p>毕竟，在注释方面按规范了对大家都更友好些。</p>

<h1 id="四-逻辑规范">四- 逻辑规范</h1>

<h2 id="1-功能分类明确">1、功能分类明确</h2>

<p>对于项目中用到的类、方法等，使用时还需注意尽量将同一类型的类、方法放在相邻位置，做好标识，以便下一次迭代更新时的快速阅读。</p>

<p>接下来就以我们就以在实际开发中最常遇到视图类的逻辑来做例子。</p>

<p>对于封装的视图类，常会用到的方法有三类：</p>

<ul>
<li>添加子视图</li>
<li>设置子视图在父视图中的位置</li>
<li>人机交互事件的设置</li>
</ul>

<p>基于此，希望至少在这一种类型封装上能形成规范，当然，能约定俗成是最好的了😄</p>

<p>我就先抛砖引玉了：</p>

<p>首先，重写系统初始化方法，下面是把将普通的init方法和可视化的初始化方法重写，</p>

<p>然后调用我们自己的初始化方法<code>- (void)commitInit</code></p>

<pre><code>//以frame初始化的方法
- (instancetype)initWithFrame:(CGRect)frame
{
    if (self = [super initWithFrame:frame]) {
        [self commitInit];
    }
    return self;
}

//以可视化控件初始化的方法
- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    if (self = [super initWithCoder:aDecoder]) {
        [self commitInit];
    }
    return self;
}

//自己的初始化方法
- (void)commitInit
{

}

</code></pre>

<p>之后在我们的初始化方法中调用需要的操作，这里我们使用了，子视图添加、约束设置和交互设置三个方法</p>

<pre><code>//初始化方法
- (void)commitInit
{
    [self theSubViewAdd];
    [self theLayoutSet];
    [self theInterfaceEventSet];
}

//添加子视图
- (void)theSubViewAdd
{

}

//设置约束
- (void)theLayoutSet
{
    
}

//设置交互
- (void)theInterfaceEventSet
{
    
}
</code></pre>

<h2 id="2-代码的重构规范">2、代码的重构规范</h2>

<blockquote>
<p>重构是一种对软件进行修改的行为，但它并不改变软件的功能特征，而是通过让软件程序更清晰，更简洁和更条理来改进软件的质量。</p>
</blockquote>

<p>代码架构最初的设计也是经过精心的设计，具有良好架构的。</p>

<p>但是随着时间的推移、需求的剧增，必须不断的修改原有的功能、追加新的功能，还免不了有一些缺陷需要修改。</p>

<p>为了实现变更，不可避免的要违反最初的设计构架。</p>

<p>经过一段时间以后，软件的架构就千疮百孔了。</p>

<p>bug越来越多，越来越难维护，新的需求越来越难实现。</p>

<p>最初的代码构架对新的需求渐渐的失去支持能力，而是成为一种制约。</p>

<p>最后新需求的开发成本会超过开发一个新的软件的成本，这就使这个app的生命走到了尽头。</p>

<h3 id="1-目的">(1) 目的</h3>

<ul>
<li>持续偏纠和改进软件设计</li>
<li>使代码更被其他人所理解</li>
<li>帮助发现隐藏的代码缺陷</li>
<li>从长远来看，有助于提高编程效率，增加项目进度（进度是质量的敌人，质量是进度的朋友）</li>
</ul>

<h3 id="2-不适用">(2) 不适用</h3>

<ul>
<li>逻辑看起来过于复杂，没时间去分析梳理。</li>
<li>不理解为什么前任程序员要这样编写。</li>
<li>负责的是一个很重要的系统，而且时间很紧。</li>
</ul>

<h3 id="3-方式">(3) 方式</h3>

<ul>
<li>权限分离</li>
</ul>

<p>对一些“臃肿的类”，应当将其中分属其它类的处理逻辑，应当及时抽离出去。</p>

<p>就以经典<code>MVC</code>模式下的赋值为例</p>

<p>有些时候我们会将<code>Model</code>层的数据处理逻辑拿到<code>View</code>或<code>Controller</code>中来用，仅把<code>Model</code>层作为一个快速解析、调用数据的工具。</p>

<pre><code>    NSString *money = [NSString stringWithFormat:@&quot;总价%@万&quot;,_money];
    self.label_money.text = money;
</code></pre>

<p>而从其各自的业务上来说，数据处理的功能也应放在<code>Model</code>层上才是</p>

<pre><code>- (NSString *)money
{
    return [NSString stringWithFormat:@&quot;总价%@万&quot;,self-&gt;_money];
}
</code></pre>

<p>从另一方面讲，这样的处理在保证单一职责的同时也牺牲掉了数据处理的灵活性。对于相当一部分对灵活性没有太多要求的模块，倒也可以不用在乎这些。</p>

<p>但是，在处理逻辑复杂、对代码的灵活性要求较高的模块中，这种处理方式是完全通过不了我们对代码逻辑可行性的判断。</p>

<p>难道彼时只能大呼“Fuck”，然后回归之前的操作方式？</p>

<p>不！作为程序员，我们可以有很多变通手段的。</p>

<p>那么，如果要兼顾这几种情形，该如何优化呢？</p>

<p>方法其实也很简单，对模型做一个包装，将其中对于数据的处理包装一层，视图层只需要获取包装后的数据就可以直接展示了。</p>

<p>这样的包装也可以算做最简单的<code>ViewModel</code>层了。</p>

<p>从这里开始，你也就开始你从<code>MVC</code>转到<code>MVVM</code>的第一步了。</p>

<p>对，没错！我就是来安利<code>MVVM</code>的。😁</p>

<ul>
<li>提取类/方法</li>
</ul>

<p>适用于以下类：</p>

<p>❶ 与其它类能共用相同的逻辑</p>

<p>❷ 与其它类在架构上一定的相似性</p>

<p>对于这些类可以提取出<span style="color:#F00">专门处理公有逻辑的新类</span>或<span style="color:#F00">架构相似的父类</span>为其减负。</p>

<ul>
<li>利用好第三方代码托管平台</li>
</ul>

<p>对于某一类在项目间通用性更强的功能模块，更好的使用方式应该是放在第三方托管平台进行托管。做好<code>Pod</code>集成和<code>Carthage</code>集成的配置</p>

<p>以便 当前功能模块的维护更新以及在下一个项目的快速导入。</p>

<h2 id="3-代码的封装">3、 代码的封装</h2>

<h3 id="1-目的-1">(1) 目的</h3>

<ol>
<li>增强安全性,简化编程。</li>
<li>使使用者只能通过事先预定的方法来访问数据,从而可以在该方法里加入控制逻辑,限制对成员变量的不合理访问。</li>
<li>可进行数据检查,有利于保证对象信息的完整性。</li>
<li>便于修改。提高代码可维护性。</li>
</ol>

<h3 id="2-优点">(2) 优点</h3>

<p>知道了封装的目的，那我们也要来列下封装的优点，这对优化和应用封装很有帮助。</p>

<ol>
<li>代码逻辑结构更加清晰。</li>
<li>冗余代码量减少，更加清爽。</li>
<li>维护量较低，符合&rdquo;对扩展开放，对修改关闭&rdquo;的软件架构思想。</li>
<li>提升开发效率</li>
</ol>

<h3 id="3-原则">(3) 原则</h3>

<ol>
<li>单一职责原则</li>
<li>接口职责单一原则</li>
<li>开放封闭原则<sup class="footnote-ref" id="fnref:open-close"><a href="#fn:open-close">1</a></sup></li>
<li>里氏替换原则<sup class="footnote-ref" id="fnref:replace"><a href="#fn:replace">2</a></sup></li>
<li>依赖倒置原则<sup class="footnote-ref" id="fnref:depend"><a href="#fn:depend">3</a></sup></li>
<li>接口隔离原则<sup class="footnote-ref" id="fnref:isolation"><a href="#fn:isolation">4</a></sup></li>
</ol>

<h3 id="4-访问控制符的使用">(4) 访问控制符的使用</h3>

<p>封装需要使用 <code>objective-c</code> 提供的4个访问控制符：<code>@private</code>,<code>@package</code>,<code>@protected</code>和<code>@public</code>。它们分别代表了4个访问控制级别。</p>

<ol>
<li><code>@private</code>：【当前类访问权限】,只能在当前类内部被访问。用于彻底隐藏成员变量。类的实现部分定义的成员变量相当于默认用这种访问权限。</li>
<li><code>@package</code>：【与映像访问权限相同】用于部分隐藏成员变量。如果类的成员变量使用<code>@package</code> 访问控制符来限制,则这个成员可以在当前类及当前类实现的同一个映像的任意地方访问。</li>
<li><code>@protected</code>：【子类访问权限】用于部分隐藏成员变量。如果类的成员变量使用<code>@protected</code> 访问控制符来限制,则这个成员可以在当前类,当前类的子类的任意地方访问。在类的接口部分定义的成员变量默认使用这种访问权限。</li>
</ol>

<p><code>@private</code>,<code>@package</code>,<code>@protected</code>和<code>@public</code>,这4个权限控制符的作用范围是这样的,从它们出现的位置开始,到下一个权限控制符出现或右边花括号之间的成员变量,都受到该访问权限控制符的控制。</p>

<h3 id="4-方式">(4) 方式</h3>

<p>尤记得刚开始封装的时候，对封装的概念了解得并不是太深，只觉得<code>AFNetworking</code>那种类型的工具才算封装，对于视图的封装只是当作建一个视图类而已。</p>

<h4 id="阶段一-暴露全部的属性-方法">阶段一 暴露全部的属性、方法</h4>

<p>将所有的属性、方法都暴露在外面，其余类可以直接访问。</p>

<p>那时候建的只是代码量很小，属性和方法也很少的类，所以一直也没感觉出什么异常。</p>

<p>后面接触的项目稍微大点，便发觉这种封装需要注意的太多，可读性也很差，遂开始优化封装来。</p>

<h4 id="阶段二-减少接口的暴露-包装接口">阶段二 减少接口的暴露，包装接口</h4>

<p>开始有意的减少接口数量，创建新的接口以执行内部逻辑。尝试创建配置模型以替换外部接口。</p>

<p>后面有更多实践了，才发现在封装类型需要多个预创建信息的时候，添加配置模型更合适。</p>

<p>并且，配置模型只需添加预创建数据接口即可，其它的接口应当放在封装类中，增强接口的可读性。</p>

<h4 id="拓展一-封装为父类">拓展一 封装为父类</h4>

<p>在某些具有共同特性的对象中，也可以根据需求提取出它们的共同特性作为父类，将相应的逻辑、属性封装为接口，供子类进行调用。</p>

<h4 id="拓展二-框架下的封装">拓展二 框架下的封装</h4>

<p>封装出一个通用的类，创建一个继承于它子类，相应逻辑在子类中实现即可。</p>

<p>注意，只允许子类访问的接口使用<code>@protected</code>来声明，避免出现不必要的bug。</p>

<h1 id="五-工具-类-的使用规范">五- 工具（类）的使用规范</h1>

<h2 id="1-手写代码-和-xib的取舍">1、手写代码 和 Xib的取舍</h2>

<p>关于这个问题相信很多同学都有困惑，参考了国内iOS界的大神<a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/">唐巧</a>和<a href="https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/">喵神</a>，结合自己在实际开发中的习惯，也就确立之后对于二者的使用了：</p>

<ul>
<li>对于复杂的、动态生成的界面，建议使用手工编写界面。</li>
<li>对于需要统一风格的按钮或UI控件，建议使用手工用代码来构造。方便之后的修改和复用。</li>
<li>对于需要有继承或组合关系的 UIView 类或 UIViewController 类，建议用代码手工编写界面。</li>
<li>对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。</li>
</ul>

<h2 id="2-工具的使用规范">2、工具的使用规范</h2>

<h3 id="1-ui调试工具">(1) UI调试工具</h3>

<p>虽然系统的也还好用，但是推荐<a href="https://revealapp.com">Reveal</a>：</p>

<ol>
<li>使用可视化的图来展示界面的层次</li>
<li>GUI 上动态改变约束可以直接应用到APP上，实时展示改变效果（个人感觉这一点对后期UI的优化还是有点帮助的）</li>
<li>对于越狱的机器，可以用Reveal来”调试“其它应用界面</li>
</ol>

<p>所以哟，尽量学着用<a href="https://revealapp.com">Reveal</a>。</p>

<h3 id="2-逻辑调试">(2) 逻辑调试</h3>

<p>断言作为<code>Objective-C</code>中居重要地位的调试工具，还是推荐大家多多使用的。</p>

<p>网上关于断言使用的介绍很多，这里也就不一一叙述了。</p>

<p>由于Xcode 已经默认将<code>release</code>环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定.</p>

<p>因此，我们可以在开发环境中尽可能的利用断言来进行项目调试。</p>

<h3 id="3-图片添加工具">(3) 图片添加工具</h3>

<p>某些特定的适合或许可以试下（设计很不靠谱的时候）<a href="https://itunes.apple.com/cn/app/asset-catalog-creator-free/id866571115?mt=12">Asset Catalog Creator</a>，</p>

<p>一键设置Icon，直接添加到系统资源库,简单粗暴。</p>

<p>有些人也许一辈子都用不上吧。</p>

<h3 id="4-性能测试工具">(4) 性能测试工具</h3>

<p>会用Xcode那对Intrument一定不会陌生了，也不多说，要优化就尽量多用吧。</p>

<h3 id="5-第三方代码托管">(5) 第三方代码托管</h3>

<p>终归还是<a href="https://github.com/">Github</a>通用性最强，各种强大的工具都能找到</p>

<p><a href="https://coding.net">Coding.net</a>也不错，主要是便宜&hellip;
开源中国的<a href="https://gitee.com/">码云</a>界面太丑，实在不想用</p>

<h1 id="六-项目的基本架构">六- 项目的基本架构</h1>

<p>关于我项目的架构，正在<a href="https://github.com/OComme/MobileProjectArchitectureDemo">MobileProjectArchitectureDemo</a>上更新，有兴趣的话可以了解了解。</p>

<h1 id="番外-代码的进化">番外 代码的进化</h1>

<p>开发已年许，代码也经历过</p>

<h3 id="代码命名">代码命名</h3>

<ul>
<li>临时定义</li>
<li>规范化</li>
</ul>

<h3 id="第三方工具集成">第三方工具集成</h3>

<ul>
<li>拖拽导入</li>
<li>拖拽导入 + <code>Pods</code>集成</li>
</ul>

<h3 id="方法布局">方法布局</h3>

<ul>
<li>毫无章法的代码集合</li>
<li>分功能实现的方法集合</li>
<li>通过标记注释来分区分块的规范方法</li>
</ul>

<h3 id="代码封装方式">代码封装方式</h3>

<ul>
<li>以控制器包装自定义的控件</li>
<li>继承<code>NSObject</code>、<code>UIResponse</code>的子类进行UI、逻辑的封装</li>
<li>特定情况下，通过继承和多态来优化封装</li>
</ul>

<h3 id="代码工具类管理">代码工具类管理</h3>

<ul>
<li>U盘、云盘存放 封装代码</li>
<li>使用云端代码仓库托管维护代码，配置<code>podspec</code></li>
</ul>

<h3 id="项目框架">项目框架</h3>

<ul>
<li>无意识、片面的<code>MVC</code>架构</li>
<li>实践优化过后的<code>MVC</code>架构</li>
<li>依据模块功能进行架构的选择（<code>MVC</code>、<code>MVVM</code>）</li>
<li>尝试<a href="https://github.com/OComme/iOS-ComponentDevelopment">组件化的项目构建</a></li>
</ul>

<p>从菜鸟到正式的开发者，从零到一，我们正在被时代拖拽着前行。</p>

<h1 id="结语">结语</h1>

<p>代码的规范不是一两天能成型的，需要持之以恒的进行思考、优化。</p>

<p>其它人的思路只能是一种参考，用以印证自己所学的局限，实际开发之后还是需要找到自己的思路，将别人的思路作为养分来浇灌自己的思路。</p>

<p>记住，我们所要强化的永远都是自己，别总想把自己变成其它人。</p>

<p>我们的目标是，星辰大海哟～！</p>

<p>&mdash;<span style="font-size:2rem">END</span>&mdash;</p>

<p>References:</p>

<p><a href="http://blog.csdn.net/f_zyj/article/details/51510085">三种编程命名规范（匈牙利命名法、驼峰式命名法、帕斯卡命名法）</a></p>

<p><a href="http://www.cnblogs.com/richieyang/p/4840614.html">编写让别人能够读懂的代码</a></p>

<p><a href="http://www.cnblogs.com/iOS-mt/p/5445284.html">IOS开发（OC）中的命名规范</a></p>

<p><a href="http://www.cocoachina.com/ios/20150508/11780.html">Objective-C开发编码规范</a></p>

<p><a href="http://www.jianshu.com/p/414bb5a53139">iOS开发总结之代码规范</a></p>

<p><a href="http://www.cnblogs.com/gfxxbk/p/5469017.html">iOS开发代码规范(通用)</a></p>

<p><a href="http://www.jianshu.com/p/71fdd1ae714c">iOS中书写代码规范35条小建议</a></p>

<p><a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/">iOS 开发中的争议（二）</a></p>

<p><a href="https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/">代码手写UI，xib和StoryBoard间的博弈，以及Interface Builder的一些小技巧</a></p>

<p><a href="http://www.jianshu.com/p/395700466a7b">iOS项目重构周记（一）</a></p>

<p><a href="http://blog.csdn.net/justinjing0612/article/details/41311577">代码重构意义和方法</a></p>

<p><a href="http://www.cnblogs.com/wujy/p/5104111.html">IOS整体项目层级构建</a></p>

<p><a href="http://www.jianshu.com/p/87fc1079d596">DRY原则的危害</a></p>

<p><a href="http://blog.csdn.net/a1056244734/article/details/50894199">Xcode TODO MARK FIXME 标记</a></p>

<p><a href="http://www.cnblogs.com/CoderAlex/p/6186599.html">程序异常处理&mdash;&ndash; 断言NSAssert()和NSParameterAssert区别和用处</a></p>

<p><a href="http://www.jianshu.com/p/7cea580441d3">iOS - 断言处理与调试</a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:open-close">开放封闭原则：对修改关闭对拓展开放
 <a class="footnote-return" href="#fnref:open-close"><sup>[return]</sup></a></li>
<li id="fn:replace">里氏替换原则：可以通过接口来调用字类
 <a class="footnote-return" href="#fnref:replace"><sup>[return]</sup></a></li>
<li id="fn:depend">依赖倒置原则：尽可能依赖底层接口
 <a class="footnote-return" href="#fnref:depend"><sup>[return]</sup></a></li>
<li id="fn:isolation">接口隔离原则：接口的方法要尽可能的少，避免万金油接口
 <a class="footnote-return" href="#fnref:isolation"><sup>[return]</sup></a></li>
</ol>
</div>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/OComme">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> OComme
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://ocomme.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://ocomme.github.io/js/main.js"></script>
<script src="https://ocomme.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
