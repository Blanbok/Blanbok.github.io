    <!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="BlanBok">
		<meta name="description" content="Some personal talk about development is about everyday thinking">
		<meta name="generator" content="Hugo 0.25.1" />
		<title>Objective-c Coding Standard &middot; BlanBok&#39;s blog</title>
		<link rel="shortcut icon" href="https://blanbok.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://blanbok.github.io/css/style.css">
		<link rel="stylesheet" href="https://blanbok.github.io/css/highlight.css">
		

		
		<link rel="stylesheet" href="https://blanbok.github.io/css/font-awesome.min.css">
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://blanbok.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://blanbok.github.io/post'>Archive</a>
	<a href='https://blanbok.github.io/tags'>Tags</a>
	<a href='https://blanbok.github.io/about'>Novel</a>

	

	
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Objective-c Coding Standard
                    </h1>
                    <h2 class="headline">
                    Aug 3, 2017 11:07
                    · 6735 words
                    · 14 minutes read
                      <span class="tags">
                      
                      
                          
                              <a href="https://blanbok.github.io/tags/ios-development">iOS-Development</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>此次规范从当前的开发现状（风格各异）出发，奠基于当前的编码习惯，旨在规范大家的编程行为。
待到下次开会的时候，仍需依据自己的习惯，提出针对性的意见。后期将参考此次会上的意见进行修订。</p>

<blockquote>
<p>最近大佬要规范下团队里的编码规范，作为狗腿子的咱自然是要响应下号召咯&hellip;顺带的自己也想把规范定下来，后面一步步的修订，方便代码更新迭代。
还是想着能让自己代码更加的简洁、明了、具有表达力的😁
希望下次谁谁看代码的时候，不用特意去对照界面就能了解这是个做什么的。</p>
</blockquote>

<hr />

<!--[TOC]-->

<h1 id="一-命名规范">一、命名规范</h1>

<p>我们所写的代码主要是为了阅读，其次才是被机器执行。所以我们要写：</p>

<ul>
<li>让别人能读懂的代码</li>
<li>可扩展的代码</li>
<li>可测试的代码(代码应该具备可测试性，对没有可测试性的代码写测试，是浪费生命的表现)</li>
</ul>

<h2 id="一-相关参考">（一）、相关参考</h2>

<h3 id="1-rc原则">1、RC原则</h3>

<blockquote>
<p>可读性高(Readable)
防止命名冲突(Conflict Name prevention)</p>
</blockquote>

<p>说到命名，就先来介绍下常用的命名方法：</p>

<h5 id="常用命名方法">常用命名方法</h5>

<h6 id="1-匈牙利命名">（1）匈牙利命名：</h6>

<p>开头字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，要求单词第一个字母大写。</p>

<pre><code>int iMyAge; “i”是int类型的缩写； 
char cMyName[10]; “c”是char类型的缩写； 
float fManHeight; “f”是float类型的缩写；
</code></pre>

<p><span id=named_02></span></p>

<h6 id="2-驼峰式命名法">（2）驼峰式命名法</h6>

<p>又叫小驼峰式命名法。
第一个单词首字母小写，后面其他单词首字母大写。</p>

<pre><code>int myAge; 
char myName[10]; 
float manHeight;
</code></pre>

<p><span id=named_03></span></p>

<h6 id="3-帕斯卡命名法">（3）帕斯卡命名法</h6>

<p>又叫大驼峰式命名法。
每个单词的第一个字母都大写。</p>

<pre><code>int MyAge; 
char MyName[10]; 
float ManHeight;
</code></pre>

<p><span id=named_04></span></p>

<h6 id="4-下划线命名法">（4）下划线命名法</h6>

<p>在命名中添加下划线用以标识
一般Object-C中建议我们在命名前加<code>_</code>，用以区分成员变量与其它变量的
在命名后加<code>_</code>，通常用在宏命名中
其它情况下在，<code>_</code>添加在标识不同含义的单词块之间用以区分</p>

<pre><code>int _myage; 
char my_name[10]; 
__FILE__
</code></pre>

<h3 id="2-tedc原则">2、TEDC原则</h3>

<blockquote>
<p>简洁(Terse)
具有表达力(Expressive)
只做一件事(Do one thing)</p>
</blockquote>

<p>Objective-C 的命名通常都比较长, 名称遵循驼峰式命名法. 一个好的命名标准很简单, 就是做到在开发者一看到名字时, 就能够懂得它的含义和使用方法.</p>

<p>有些时候这三者也会有起冲突的时候，怎么取舍呢？</p>

<p>借用官方的例子</p>

<p><span id=TEDC_01></span></p>

<h4 id="表达力-简洁">表达力 &gt; 简洁</h4>

<blockquote>
<p>尽可能具有表达力和简洁是好的，但是表达力不应该因为简洁而受到影响。</p>
</blockquote>

<table>
<thead>
<tr>
<th>代码</th>
<th>点评</th>
</tr>
</thead>

<tbody>
<tr>
<td>insertObject:atIndex:</td>
<td>Good</td>
</tr>

<tr>
<td>insert:at:</td>
<td>不清晰;要插⼊什么?“at”表⽰示什么?</td>
</tr>

<tr>
<td>removeObjectAtIndex:</td>
<td>Good</td>
</tr>

<tr>
<td>removeObject:</td>
<td>不错,因为⽅法是⽤用来移除作为参数的对象</td>
</tr>

<tr>
<td>remove:</td>
<td>不清晰;要移除什么?</td>
</tr>
</tbody>
</table>

<h4 id="清晰表达意思">清晰表达意思</h4>

<blockquote>
<p>一般来说，不要缩写事物的名称。把它们拼出来，即使它们很长:</p>
</blockquote>

<table>
<thead>
<tr>
<th>代码</th>
<th>点评</th>
</tr>
</thead>

<tbody>
<tr>
<td>destinationSelection</td>
<td>Good</td>
</tr>

<tr>
<td>destSel</td>
<td>不清晰</td>
</tr>

<tr>
<td>setBackgroundColor:</td>
<td>Good</td>
</tr>

<tr>
<td>setBkgdColor:</td>
<td>不清晰</td>
</tr>
</tbody>
</table>

<h4 id="避免歧义">避免歧义</h4>

<blockquote>
<p>避免API名称中的歧义，例如可以用多种方法解释的方法名</p>
</blockquote>

<table>
<thead>
<tr>
<th>代码</th>
<th>点评</th>
</tr>
</thead>

<tbody>
<tr>
<td>sendPort</td>
<td>它是发送端口还是返回?</td>
</tr>

<tr>
<td>displayName</td>
<td>它是在用户界面中显示一个名称还是返回接收者的标题?</td>
</tr>
</tbody>
</table>

<p>需要察看更多的规范，请前往<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-BBCHBFAH">官方文档</a></p>

<h2 id="二-实际规范">（二）、 实际规范</h2>

<h4 id="1-变量命名">1、变量命名</h4>

<h5 id="1-一般变量命名">（1）一般变量命名</h5>

<p><span style="color:#F00">命名方式</span>：【小写类型前缀+<code>_</code>+介绍<a href="#named_02">小驼峰式</a>】的做法。【介绍尽量用自然语言表达自己的意思。】</p>

<p>于个人而言，变量名使用更多的是下划线加驼峰式的命名，尽量用自然语言命名自己的变量</p>

<pre><code>@property (nonnull,nonatomic,strong) UIImageView *imageView_head;
</code></pre>

<h5 id="2-模型内的属性命名">（2）模型内的属性命名</h5>

<p><span style="color:#F00">命名方式</span>：<a href="#named_04">下划线命名</a></p>

<p>坚持<span style="color:#F00">一致性</span>的原则</p>

<p>当下后台属性命名方式：<a href="#named_04">下划线命名</a></p>

<p>对于用于解析后台数据的模型，应尽量保持与后台命名方式一致，最好能命名完全一致
对于用于处理本地数据的模型，也应保持与后台命名方式一致。</p>

<p><span style="color:#F00"><strong>即应保证具有某一共同功能的类型命名方式一致。</strong></span></p>

<h4 id="2-类命名">2、类命名</h4>

<p><span style="color:#F00">命名方式</span>：<a href="#named_03">大驼峰式命名法</a></p>

<p>对于一般的类，通常是使用大驼峰式的命名方式
类名的拼写方式一般采用<span style="color:#F00">[标识 + 模块名称+功能介绍+类型]</span>
<strong>标识</strong>用于区分其它第三方的类，一般为开发者或者开发公司的标识
<strong>模块名称</strong>标识当前类在界面中所处模块名称
<strong>功能介绍</strong>标识当前类在当前模块中的作用
<strong>类型</strong>标识当前类的类型</p>

<p>其中最有争议的应该是<strong>模块名称</strong></p>

<table>
<thead>
<tr>
<th>位置</th>
<th>模块名称</th>
</tr>
</thead>

<tbody>
<tr>
<td>根控制器</td>
<td><code>Base</code></td>
</tr>

<tr>
<td>一般控制器</td>
<td>其根控制器的<strong>功能介绍</strong></td>
</tr>

<tr>
<td>一般视图</td>
<td>下一级响应者（父视图或是其所属的控制器）的<strong>功能介绍</strong></td>
</tr>

<tr>
<td>通用控制器（例如：登陆、注册或者是好几个<code>TabBar</code>分栏都会跳转的控制器）</td>
<td><code>public</code></td>
</tr>

<tr>
<td>通用视图（用于多个界面的视图）</td>
<td><code>public</code></td>
</tr>
</tbody>
</table>

<p>对控制器而言，模块名称即其根视图的<strong>功能介绍</strong>，若当前控制器即根控制器，则当前控制器的模块标识为<code>Base</code></p>

<p>对于类名，小子是按其在界面中的层次进行命名
对于处于界面第一级的视图 将它的 上一级功能名称的 拼接字段定为<code>Base</code>
如<code>JYBaseHomeViewController</code> 表示首页的根控制器
其中</p>

<table>
<thead>
<tr>
<th>标识</th>
<th>上一级功能</th>
<th>功能介绍</th>
<th>类型</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>JY</code></td>
<td><code>Base</code></td>
<td><code>Home</code></td>
<td><code>ViewController</code></td>
</tr>
</tbody>
</table>

<h4 id="3-方法命名">3、方法命名</h4>

<p><span style="color:#F00">命名方式</span>：<a href="#named_02">小驼峰式命名法</a></p>

<p>方法名应遵守小驼峰原则，首字母小写，其他单词首字母大写,每个空格分割的名称以动词开头。执行性的方法应该以动词开头，小写字母开头，返回性的方法应该以返回的内容开头，但之前不要加get。</p>

<p>方法名应具备以下特征</p>

<h5 id="1-表达力-简洁">（1）表达力、简洁</h5>

<p>方法名应该是简洁并具有表达力，去除参数之后能形成可读的自然语言
当这二者需要取舍，应该<a href="#TEDC_01">着重强调表达力</a></p>

<p>例如：</p>

<p>使用<code>insertObject:(NSObject*)object  atIndex: (NSInteger)index</code></p>

<p>比<code>insert:(NSObject*)object at: (NSInteger)index</code>更合适</p>

<p>给它们去掉参数，变成自然语言即 “<span style="color:#F00">insert Object at Index</span>”对“<span style="color:#F00">insert at</span>”，孰优孰劣一目了然</p>

<h5 id="2-只做一件事">（2）只做一件事</h5>

<p>当你无法为你的方法起一个准确的名称时，很可能你的方法不止做了一件事，违反了(Do one thing)。特别是你想在方法名中加入：And，Or，If等词时</p>

<pre><code>- (void)RegisterUser:(User*) user SendEmail:(bool)sendEmail
{
    
}
</code></pre>

<p>此时，应该将执行不同逻辑操作的方法分开，构成两个不同的方法来执行</p>

<pre><code>- (void)RegisterUser:(User*)user
{

}

- (void)SendEmail:(User*)user
{

}
</code></pre>

<h5 id="3-尽可能少的参数">（3） 尽可能少的参数</h5>

<p>过多的参数让读者难以抓住代码的意图，同时过多的参数将会影响方法的稳定性。另外也预示着参数应该聚合为一个<code>Model</code></p>

<p>参数为<span style="color:#F00">1-2</span>个最合适</p>

<pre><code>- (void) RegisterUserName:(NSString*)userName Password:(NSString*) password Email:(NSString*) email  Phone:(NSString*)phone
{

}
</code></pre>

<p>此时参数超过3个，可以聚合成为一个模型，以增强可读性</p>

<pre><code>- (void) RegisterUser:(User*)user
{

}
</code></pre>

<h4 id="4-类别命名">4、类别命名</h4>

<p><span style="color:#F00">命名方式</span>：[类名+标识+扩展（<a href="#named_03">大驼峰式</a>）]</p>

<p>例：如果我们想要创建一个基于<code>NSString</code>的类别用于判断字符串类型，我们应该把类别放到名字是<code>NSString+JYJudgmentType</code>的文件里。<code>NSString</code>为要扩展的类名，<code>JY</code>为标识，<code>JudgmentType</code>为扩展的功能。</p>

<h4 id="5-枚举的命名">5、枚举的命名</h4>

<p><span style="color:#F00">命名方式</span>：[标识+功能（<a href="#named_03">大驼峰式</a>）]</p>

<p>类型命名：[枚举名+特征]</p>

<p>下面我们列举一组用于判断字符串类型的枚举</p>

<pre><code>typedef NS_ENUM(NSInteger,JYJudgmentType){
    ///数字
    JYJudgmentTypeNumberCharacters             = 1,
    ///英文
    JYJudgmentTypeOrdinaryEnglishCharacters    = 1 &lt;&lt; 1,
    ///中文
    JYJudgmentTypeChineseCharacters            = 1 &lt;&lt; 2,
    ///电话
    JYJudgmentTypeMobile               = 1 &lt;&lt; 3,
    ///身份证
    JYJudgmentTypeIDCard               = 1 &lt;&lt; 4,
    ///银行卡
    JYJudgmentTypeBankCard             = 1 &lt;&lt; 5,
    ///邮箱
    JYJudgmentTypeEmail             = 1 &lt;&lt; 6,
};
</code></pre>

<p>我们就以<code>JYJudgmentTypeNumberCharacters</code>为例</p>

<p><code>JY</code>为标识，<code>JudgmentType</code>为该枚举的功能，<code>NumberCharacters</code>为当前类型的特征</p>

<h4 id="6-const常量">6、const常量</h4>

<p><span style="color:#F00">命名方式</span>：<a href="#named_03">大驼峰式</a></p>

<p>如果一定想要和其它变量区分开来，也可以给他一个标识</p>

<p>最明显的例子就是我们常用的<code>ReuseIdentifier</code></p>

<h4 id="7-宏命名">7、宏命名</h4>

<p><span style="color:#F00">命名方式</span>：<a href="#named_04">下划线命名</a>+全部字母大写
毕竟官方推荐命名方式
例如系统的宏<code>__FILE__</code>
我们也可以加上自己的标识用以和系统的宏区分开来<code>JY__FILE__</code>
如果还要标识宏隶属于某一模块的话，还可以更进一步的加上模块的标识<code>JY__SQL__FILE__</code></p>

<h1 id="二-注释规范">二、注释规范</h1>

<blockquote>
<p>关于注释，虽说是有很大一份人认为优秀的代码可以完全替代注释，然而在实际上，英语这么强的还是很少的🤦‍♂️。而且对我们来说，用尽可能低的标准来要求别人，项目可维护性。（唔，连中文注释都看不懂那就无解了😒）
注释不用做得太夸张，由于开发中阅读注释大部分都只是为了关联或者了解某项功能，所以我们只需在关键点添加注释即可。</p>
</blockquote>

<h3 id="1-类前的注释">1、类前的注释</h3>

<p>类的 <code>.h</code>文件中添加一段标识注释，用以解释当前类的用法</p>

<pre><code>/*
 创建人：（标识创建）
 创建版本：创建类的版本（了解功能在哪一个版本添加或重构）
 功能描述：介绍类的主要功能（让读者一目了然）
 --修改人：（标识功能修改者）
 修改版本：类修改的版本（哪个版本有进行修订）
 修改描述：（修订某一功能）
 ···：重复【修改人 — 修改版本 — 修改描述】三列的介绍。&quot;创建人&quot;在之后的修改过程中也将作为&quot;修改人&quot;
 */
</code></pre>

<h3 id="2-接口注释">2、接口注释</h3>

<p>推荐使用 <code>option</code>+<code>command</code>+<code>/</code>快捷注释命令
对类的接口处的属性、方法进行介绍</p>

<p>属性：</p>

<pre><code>/**
 介绍属性
 */
@property (nonnull,nonatomic,strong) NSObject *object;
</code></pre>

<p>方法：</p>

<pre><code>/**
 介绍方法功能

 @param obj 参数介绍
 */
- (void)RegisterUser:(User*)user;
</code></pre>

<h1 id="三-逻辑规范">三、逻辑规范</h1>

<h3 id="一-视图类的公有方法">（一）视图类的公有方法</h3>

<p>对于封装的视图类，常会用到的方法有三类：</p>

<ul>
<li>添加子视图</li>
<li>设置子视图在父视图中的位置</li>
<li>人机交互事件的设置</li>
</ul>

<p>基于此，希望至少在这一种类型封装上能形成规范，当然，能约定俗成是最好的了😄</p>

<p>我就先抛砖引玉了：</p>

<p><span style="color:#F00">首先</span> 重写系统初始化方法，下面是把将普通的init方法和可视化的初始化方法重写，然后调用我们自己的初始化方法<code>- (void)commInit</code></p>

<pre><code>//以frame初始化的方法
- (instancetype)initWithFrame:(CGRect)frame
{
    if (self = [super initWithFrame:frame]) {
        [self commInit];
    }
    return self;
}

//以可视化控件初始化的方法
- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    if (self = [super initWithCoder:aDecoder]) {
        [self commInit];
    }
    return self;
}

//自己的初始化方法
- (void)commInit
{

}

</code></pre>

<p>之后在我们的初始化方法中调用需要的操作，这里我们使用了，子视图添加、约束设置和交互设置三个方法</p>

<pre><code>//初始化方法
- (void)commInit
{
    [self theSubViewAdd];
    [self theLayoutSet];
    [self theInterfaceEventSet];
}

//添加子视图
- (void)theSubViewAdd
{

}

//设置约束
- (void)theLayoutSet
{
    
}

//设置交互
- (void)theInterfaceEventSet
{
    
}
</code></pre>

<h3 id="二-代码的重构规范">（二）代码的重构规范</h3>

<blockquote>
<p>重构是一种对软件进行修改的行为，但它并不改变软件的功能特征，而是通过让软件程序更清晰，更简洁和更条理来改进软件的质量。</p>
</blockquote>

<p>代码架构最初的设计也是经过精心的设计，具有良好架构的。但是随着时间的推移、需求的剧增，必须不断的修改原有的功能、追加新的功能，还免不了有一些缺陷需要修改。为了实现变更，不可避免的要违反最初的设计构架。经过一段时间以后，软件的架构就千疮百孔了。bug越来越多，越来越难维护，新的需求越来越难实现，最初的代码构架对新的需求渐渐的失去支持能力，而是成为一种制约。最后新需求的开发成本会超过开发一个新的软件的成本，这就使这个app的生命走到了尽头。</p>

<h4 id="1-目的">1、目的</h4>

<p>（1）持续偏纠和改进软件设计</p>

<p>（2）使代码更被其他人所理解</p>

<p>（3）帮助发现隐藏的代码缺陷</p>

<p>（4）从长远来看，有助于提高编程效率，增加项目进度（进度是质量的敌人，质量是进度的朋友）</p>

<h4 id="2-不适用">2、不适用</h4>

<p>（1）逻辑看起来过于复杂，没时间去分析梳理。</p>

<p>（2）不理解为什么前任程序员要这样编写。</p>

<p>（3）负责的是一个很重要的系统，而且时间很紧。</p>

<h4 id="3-方式">3、方式</h4>

<h5 id="1-权限分离">（1）权限分离</h5>

<p>对一些“臃肿的类”，应当将其中分属其它类的处理逻辑，应当及时抽离出去。</p>

<p>就以经典<code>MVC</code>模式下的赋值为例</p>

<p>有些时候我们会将<code>Model</code>层的数据处理逻辑拿到<code>View</code>或<code>Controller</code>中来用，仅把<code>Model</code>层作为一个快速解析、调用数据的工具。</p>

<pre><code>    NSString *money = [NSString stringWithFormat:@&quot;总价%@万&quot;,_money];
    self.label_money.text = money;
</code></pre>

<p>而从其各自的业务上来说，数据处理的功能也应放在<code>Model</code>层上才是</p>

<pre><code>- (NSString *)money
{
    return [NSString stringWithFormat:@&quot;总价%@万&quot;,self-&gt;_money];
}
</code></pre>

<h5 id="2-提取类-方法">（2）提取类/方法</h5>

<p>适用于以下类：</p>

<p>❶ 与其它类能共用相同的逻辑</p>

<p>❷ 与其它类在架构上一定的相似性</p>

<p>对于这些类可以提取出<span style="color:#F00">专门处理公有逻辑的新类</span>或<span style="color:#F00">架构相似的父类</span>为其减负。</p>

<h5 id="3-利用好第三方代码托管平台">（3 ）利用好第三方代码托管平台</h5>

<p>对于某一类在项目间通用性更强的功能模块，更好的使用方式应该是放在第三方托管平台进行托管。做好<code>Pod</code>集成和<code>Carthage</code>集成的配置</p>

<p>以便 当前功能模块的维护更新以及在下一个项目的快速导入。</p>

<h1 id="四-工具-类-的使用规范">四、工具（类）的使用规范</h1>

<h3 id="一-手写代码-和-xib的取舍">（一）手写代码 和 Xib的取舍</h3>

<p>关于这个问题相信很多同学都有困惑，参考了国内iOS界的大神<a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/">唐巧</a>和<a href="https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/">喵神</a>，结合自己在实际开发中的习惯，也就确立之后对于二者的使用了：</p>

<ul>
<li>对于复杂的、动态生成的界面，建议使用手工编写界面。</li>
<li>对于需要统一风格的按钮或UI控件，建议使用手工用代码来构造。方便之后的修改和复用。</li>
<li>对于需要有继承或组合关系的 UIView 类或 UIViewController 类，建议用代码手工编写界面。</li>
<li>对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。</li>
</ul>

<h3 id="二-工具类的使用规范">（二）工具类的使用规范</h3>

<h4 id="1-ui调试工具">1、UI调试工具</h4>

<p>对于UI的调试，据我所知的有两种：</p>

<p><a href="https://revealapp.com">Reveal</a>和<a href="http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/">UIDebuggingInformationOverlay</a></p>

<p>二者的用法同等便利，但<a href="https://revealapp.com">Reveal</a>比起<a href="http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/">UIDebuggingInformationOverlay</a>来功能无疑是丰富许多。</p>

<p><a href="http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/">UIDebuggingInformationOverlay</a>现有的功能：</p>

<ol>
<li>列出界面层次、视图位置、从属关系</li>
<li>对比设计图与APP运行时界面</li>
<li>获取界面上的目标约束</li>
</ol>

<p><a href="https://revealapp.com">Reveal</a>仅咱现在用到的功能在<a href="http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/">UIDebuggingInformationOverlay</a>功能的基础上多了：
1. 使用可视化的图来展示界面的层次
2. GUI 上动态改变约束可以直接应用到APP上，实时展示改变效果（个人感觉这一点对后期UI的优化还是有点帮助的）
3. 对于越狱的机器，可以用Reveal来”调试“其它应用界面</p>

<p>所以说哟，能使用<a href="https://revealapp.com">Reveal</a>还是用它为好，<a href="http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/">UIDebuggingInformationOverlay</a>更多是在懒得使用或者实在用不了<a href="https://revealapp.com">Reveal</a>的时候再用好了😦</p>

<h4 id="2-图片添加工具">2、图片添加工具</h4>

<p>说起来APPIcon，用得上的图片算起来也有8张了，没什么反人类的要求的话，图片内容基本一致，也仅是尺寸不一样，如果设计那边没什么便利的工具的话，那倒是可以使用下  <a href="https://itunes.apple.com/cn/app/asset-catalog-creator-free/id866571115?mt=12">Asset Catalog Creator</a>，</p>

<p>一键设置Icon，直接添加到系统资源库,简单粗暴。</p>

<h4 id="3-项目优化工具">3、项目优化工具</h4>

<p>会用Xcode那对Intrument一定不会陌生了，也不多说，要优化就尽量多用吧。</p>

<h4 id="4-第三方代码托管">4、第三方代码托管</h4>

<p>终归还是<a href="https://github.com/">Github</a>最通用</p>

<h1 id="五-项目的基本架构">五、项目的基本架构</h1>

<pre><code>    ├── &lt;Supporting Files&gt;(放置预编译文件、系统配置文件和`APPDelegate.*`类)
    ├── &lt;Utils&gt;（适用于本项目的自定义类库。根据功能可以细分下去。例如：UI类、Data类、Net类）
    ├── &lt;BaseController&gt;（控制器的基类，方能统一管理控制器的各项特征）
    ├── &lt;TabBarController&gt;（窗口根控制器）
    ├── &lt;CodeClass&gt;（项目真正的构建内容）
    └── &lt;Pods（或Carthage）&gt;工程（第三方SDK以及自己做的小工具）
</code></pre>

<p>在XCode上创建时，如果有个比较清晰的层级构建，将对以后的项目维护和功能的拓展很有帮助。</p>

<p>这次，将简要描述对项目层级的拙见。</p>

<h3 id="1-cocoapods">1、CocoaPods</h3>

<p>关于第三方的工具，想必大家现在都用的是第三方的管理工具来进行集成。比较出名的就是<code>CocoaPods</code>和<code>Carthage</code>，惭愧的是咱还完全没了解过<code>Carthage</code>（懒过头了点 ..😄）。所以唯一能说的也就是<code>CocoaPods</code>了。</p>

<p><code>Pods</code>不仅仅只是用来集成别人的工具，也是能用管理、集成自己的工具。</p>

<p>别怕自己的代码放到<a href="https://github.com/">Github</a>上被人笑话，传上去的初衷是为了便利自己而已，其它什么的都是添头。</p>

<p>想想，你做了个小工具，之后创建好几个项目的时候都是一个个拖进去，之后可能发现其中的逻辑出来了致命的bug。难道优化之后，还得一个个的项目拖过去？</p>

<p>省省把，工具本来就是帮我们提升开发效率的，你却将这么强大的功能弃置不顾，仅仅把它作为一个便利的获取轮子的工具，确实该自省了！</p>

<h3 id="2-supporting-files">2、Supporting Files</h3>

<p>对于些系统的配置文件 <code>Info.plist</code>、<code>InfoPlist.strings</code>和预编译的文件<code>.pch</code>、<code>header File</code>以及<code>main.m</code>主函数。</p>

<p>通常我们在项目创建之后，对这些文件的访问频率都会很低的，因此可以将它们都放做一块，统一管理。</p>

<h3 id="3-utils">3、Utils</h3>

<p>对于适用性很小，仅在当前项目中通用的工具类。我们统一放在Utils类目下，分门别类的列出来。</p>

<h3 id="4-basecontroller">4、BaseController</h3>

<p>放置控制器的基类，方能统一管理控制器的各项特征。</p>

<p>项目中应该是尽量少的创建基类，否则项目内部模块的耦合性会达到自己都不能理清的地步。</p>

<h3 id="4-tabbarcontroller">4、TabBarController</h3>

<p>对于窗口的根控制器，它的位置是有点尴尬。作为一个控制器，它应该放在<code>CodeClass</code>里面，但这样也将这类目强行加了一层。作为一个创建之后就确定的，不会轻易改变的类，它也可以放置在<code>Supporting Files</code>里。</p>

<p>既然都不好下决定，索性就新开一层，专门放置好了。</p>

<h3 id="5-codeclass">5、CodeClass</h3>

<p>项目构建的实际结构，按照界面层次逐层的创建下去。</p>

<p>其内部构架就按经典<code>MVC</code>，分类的文件夹直接标以<code>M</code>、<code>V</code>、<code>C</code>，对模块的构架就一目了然了。</p>

<p>&mdash; <span style="font-size:2rem">END</span> &mdash;</p>

<h1 id="references">References</h1>

<p><a href="http://blog.csdn.net/f_zyj/article/details/51510085">三种编程命名规范（匈牙利命名法、驼峰式命名法、帕斯卡命名法）</a></p>

<p><a href="http://www.cnblogs.com/richieyang/p/4840614.html">编写让别人能够读懂的代码</a></p>

<p><a href="http://www.cnblogs.com/iOS-mt/p/5445284.html">IOS开发（OC）中的命名规范</a></p>

<p><a href="http://www.cocoachina.com/ios/20150508/11780.html">Objective-C开发编码规范</a></p>

<p><a href="http://www.jianshu.com/p/414bb5a53139">iOS开发总结之代码规范</a></p>

<p><a href="http://www.cnblogs.com/gfxxbk/p/5469017.html">iOS开发代码规范(通用)</a></p>

<p><a href="http://www.jianshu.com/p/71fdd1ae714c">iOS中书写代码规范35条小建议</a></p>

<p><a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/">iOS 开发中的争议（二）</a></p>

<p><a href="https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/">代码手写UI，xib和StoryBoard间的博弈，以及Interface Builder的一些小技巧</a></p>

<p><a href="http://www.jianshu.com/p/395700466a7b">iOS项目重构周记（一）</a></p>

<p><a href="http://blog.csdn.net/justinjing0612/article/details/41311577">代码重构意义和方法</a></p>

<p><a href="http://www.cnblogs.com/wujy/p/5104111.html">IOS整体项目层级构建</a></p>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/Blanbok">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2017 <i class="fa fa-heart" aria-hidden="true"></i> BlanBok
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://blanbok.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://blanbok.github.io/js/main.js"></script>
<script src="https://blanbok.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
