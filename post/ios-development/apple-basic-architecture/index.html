    <!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="OComme">
		<meta name="description" content="Some personal talk about development is about everyday thinking">
		<meta name="generator" content="Hugo 0.25.1" />
		<title>Apple Basic architecture &middot; OComme&#39;s blog</title>
		<link rel="shortcut icon" href="https://ocomme.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://ocomme.github.io/css/style.css">
		<link rel="stylesheet" href="https://ocomme.github.io/css/highlight.css">
		

		
		<link rel="stylesheet" href="https://ocomme.github.io/css/font-awesome.min.css">
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://ocomme.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://ocomme.github.io/post'>Archive</a>
	<a href='https://ocomme.github.io/tags'>Tags</a>
	<a href='https://ocomme.github.io/about'>Novel</a>

	

	
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Apple Basic architecture
                    </h1>
                    <h2 class="headline">
                    Sep 22, 2017 09:00
                    · 9375 words
                    · 19 minutes read
                      <span class="tags">
                      
                      
                          
                              <a href="https://ocomme.github.io/tags/ios-development">iOS-Development</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<!--[TOC]-->

<h1 id="关于架构">关于架构</h1>

<blockquote>
<p>架构，又名软件架构，是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。</p>
</blockquote>

<h2 id="一-基本概念">(一) 基本概念</h2>

<p>软件架构（software architecture）是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。</p>

<p>软件架构是一个系统的草图。</p>

<p>软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。</p>

<p>在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。</p>

<p>在面向对象领域中，组件之间的连接通常用接口来实现。 软件体系结构是构建计算机软件实践的基础。</p>

<p>一般而言，软件系统的架构（Architecture）有两个要素：</p>

<p>1、它是一个软件系统从整体到部分的最高层次的划分。</p>

<p>一个系统通常是由元件组成的，而这些元件如何形成、相互之间如何发生作用，则是关于这个系统本身结构的重要信息。</p>

<p>详细地说，就是要包括架构元件（Architecture Component）、联结器（Connector）、任务流（Task-flow）。</p>

<p>所谓架构元素，也就是组成系统的核心&rdquo;砖瓦&rdquo;，而联结器则描述这些元件之间通讯的路径、通讯的机制、通讯的预期结果，任务流则描述系统如何使用这些元件和联结器完成某一项需求。</p>

<p>2、建造一个系统所作出的最高层次的、以后难以更改的，商业的和技术的决定。</p>

<p>在建造一个系统之前会有很多的重要决定需要事先作出，而一旦系统开始进行详细设计甚至建造，这些决定就很难更改甚至无法更改。</p>

<p>显然，这样的决定必定是有关系统设计成败的最重要决定，必须经过非常慎重的研究和考察。‘</p>

<h2 id="二-设计目标">(二) 设计目标</h2>

<p>1、可靠性（Reliable）。</p>

<p>软件系统对于用户的商业经营和管理来说极为重要，因此软件系统必须非常可靠。</p>

<p>2、安全性（Secure）。</p>

<p>软件系统所承担的交易的商业价值极高，系统的安全性非常重要。</p>

<p>3、可扩展性（Scalable）。</p>

<p>软件必须能够在用户的使用率、用户的数目增加很快的情况下，保持合理的性能。只有这样，才能适应用户的市场扩展得可能性。</p>

<p>4、可定制化（Customizable）。</p>

<p>同样的一套软件，可以根据客户群的不同和市场需求的变化进行调整。</p>

<p>5、可伸缩 （Extensible）。</p>

<p>在新技术出现的时候，一个软件系统应当允许导入新技术，从而对现有系统进行功能和性能的扩展。</p>

<p>6、可维护性（Maintainable）。</p>

<p>软件系统的维护包括两方面，一是排除现有的错误，二是将新的软件需求反映到现有系统中去。一个易于维护的系统可以有效地降低技术支持的花费。</p>

<p>7、客户体验（Customer Experience）。</p>

<p>软件系统必须易于使用。</p>

<p>8、市场时机（Time to Market）。</p>

<p>软件用户要面临同业竞争，软件提供商也要面临同业竞争。以最快的速度争夺市场先机非常重要。</p>

<h2 id="三-构架设计的方法">(三) 构架设计的方法</h2>

<p>1、搞清楚要解决哪些问题，并找到解决这些问题的充要条件。</p>

<p>2、问题分类，分模块</p>

<p>3、搞清楚各问题之间的依赖关系，建立好模块交流规范并设计模块。</p>

<p>4、推演预测一下未来可能的走向，必要时添加新的模块，记录更多的基础数据以备未来之需。</p>

<p>5、先解决依赖关系中最基础的问题，实现基础模块，然后再用基础模块堆叠出整个架构。</p>

<p>6、打点，跑单元测试，跑性能测试，根据数据去优化对应的地方。</p>

<h2 id="四-种类">(四) 种类</h2>

<p>根据我们关注的角度不同，可以将架构分成三种：</p>

<p>1、逻辑架构、软件系统中元件之间的关系，比如用户界面，数据库，外部系统接口，商业逻辑元件，等等。</p>

<p>2、物理架构、软件元件是怎样放到硬件上的。</p>

<p>3、系统架构、系统的非功能性特征，如可扩展性、可靠性、强壮性、灵活性、性能等。系统架构的设计要求架构师具备软件和硬件的功能和性能的过硬知识，这一工作无疑是架构设计工作中最为困难的工作。</p>

<h2 id="五-好架构的标准">(五) 好架构的标准</h2>

<ul>
<li>代码整齐，分类明确，没有common，没有core</li>
<li>不用文档，或很少文档，就能让业务方上手</li>
<li>思路和方法要统一，尽量不要多元</li>
<li>没有横向依赖，万不得已不出现跨层访问</li>
<li>对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件</li>
<li>易测试，易拓展</li>
<li>保持一定量的超前性</li>
<li>接口少，接口参数少</li>
<li>高性能</li>
</ul>

<h2 id="六-构架设计图">(六) 构架设计图</h2>

<p>构架视图的图形描述称为构架设计图。设计图由以下统一建模语言图组成 ：</p>

<ul>
<li>逻辑视图：类图、状态机和对象图。</li>
<li>进程视图：类图与对象图（包括任务 - 进程与线程）。</li>
<li>实施视图：构件图。</li>
<li>部署视图：配置图。</li>
<li>用例视图：用例图描述用例、主角和普通设计类；顺序图描述设计对象及其协作关系。</li>
</ul>

<h1 id="常用的架构">常用的架构</h1>

<h2 id="一-mvc">(一) MVC</h2>

<blockquote>
<p>MVC（Model-View-Controller）是最老牌的的思想，其中Model就是作为数据管理者，View作为数据展示者，Controller作为数据加工者，Model和View又都是由Controller来根据业务需求调配，所以Controller还负担了一个数据流调配的功能。</p>
</blockquote>

<h3 id="mvc如何分工">MVC如何分工</h3>

<h4 id="模型-model-的分工">模型（Model）的分工：</h4>

<ul>
<li>为ViewController提供数据</li>
<li>为ViewController存储数据提供接口</li>
<li>提供经过抽象的业务基本组件，供Controller调度</li>
</ul>

<h4 id="控制器-controller-的分工">控制器（Controller）的分工：</h4>

<ul>
<li>管理View Container的生命周期</li>
<li>负责生成所有的View实例，并放入View Container</li>
<li>监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。</li>
</ul>

<h4 id="视图-view-的分工">视图（View）的分工：</h4>

<ul>
<li>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。</li>
<li>界面元素表达</li>
</ul>

<p><img src="https://raw.githubusercontent.com/OComme/OComme.github.io/master/Assets/Basic%20architecture/image1.png" alt="" /></p>

<h4 id="分工总结">分工总结:</h4>

<ul>
<li>视图（View）：用户界面</li>
<li>控制器（Controller）：业务逻辑及处理</li>
<li>模型（Model）：数据存储</li>
</ul>

<h3 id="mvc通信特点">MVC通信特点</h3>

<p><img src="https://raw.githubusercontent.com/OComme/OComme.github.io/master/Assets/Basic%20architecture/image2.gif" alt="" /></p>

<p>1、Model和View永远不能相互通信，只能通过Controller传递。</p>

<p>2、Controller可以直接与Model通信（读写调用Model），Model通过Notification和KVO机制与Controller间接通信。</p>

<p>3、Controller与View通过Target/Action, delegate和datasource三种模式进行通信。通过这三种模式，View就可以向Controller通信, Action/Target 模式来让Controller 监听View 触发的事件。View又通过Data source和delegate进行数据获取和某些通信操作。</p>

<h3 id="mvc总结">MVC总结</h3>

<ul>
<li>任务均摊–View和Model确实是分开的，但是View和Controller却是紧密耦合的</li>
<li>可测试性–由于糟糕的分散性，只能对Model进行测试</li>
<li>易用性–与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。</li>
</ul>

<h2 id="二-mvcs">(二) MVCS</h2>

<blockquote>
<p>苹果自身就采用的是这种架构思路，从名字也能看出，也是基于MVC衍生出来的一套架构。从概念上来说，它拆分的部分是Model部分，拆出来一个Store。这个Store专门负责数据存取。但从实际操作的角度上讲，它拆开的是Controller。</p>
</blockquote>

<h3 id="mvcs如何分工">MVCS如何分工</h3>

<p>这算是瘦Model的一种方案，瘦Model只是专门用于表达数据，然后存储、数据处理都交给外面的来做。</p>

<p>MVCS使用的前提是，它假设了你是瘦Model，同时数据的存储和处理都在Controller去做。</p>

<p>所以对应到MVCS，它在一开始就是拆分的Controller。</p>

<p>因为Controller做了数据存储的事情，就会变得非常庞大，那么就把Controller专门负责存取数据的那部分抽离出来，交给另一个对象去做，这个对象就是Store。</p>

<p>这么调整之后，整个结构也就变成了真正意义上的MVCS。</p>

<h4 id="分工总结-1">分工总结:</h4>

<ul>
<li>视图（View）：用户界面</li>
<li>控制器（Controller）：业务逻辑及处理</li>
<li>模型（Model）：数据存储</li>
<li>存储器（Store）：数据处理逻辑</li>
</ul>

<p>MVCS是基于瘦Model的一种架构思路，把原本Model要做的很多事情中的其中一部分关于数据存储的代码抽象成了Store，在一定程度上降低了Controller的压力。</p>

<h4 id="关于胖model和瘦model">关于胖Model和瘦Model</h4>

<h5 id="胖model-fat-model">胖Model (Fat Model)</h5>

<p>胖Model包含了部分弱业务逻辑。胖Model要达到的目的是，Controller从胖Model这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在View上。</p>

<p>FatModel做了这些弱业务之后，Controller就能变得非常skinny，Controller只需要关注强业务代码就行了。</p>

<p>众所周知，强业务变动的可能性要比弱业务大得多，弱业务相对稳定，所以弱业务塞进Model里面是没问题的。</p>

<p>另一方面，弱业务重复出现的频率要大于强业务，对复用性的要求更高，如果这部分业务写在Controller，类似的代码会洒得到处都是，一旦弱业务有修改（弱业务修改频率低不代表就没有修改），这个事情就是一个灾难。</p>

<p>如果塞到Model里面去，改一处很多地方就能跟着改，就能避免这场灾难。</p>

<p>然而其缺点就在于，胖Model相对比较难移植，虽然只是包含弱业务，但好歹也是业务，迁移的时候很容易拔出萝卜带出泥。</p>

<p>另外一点，MVC的架构思想更加倾向于Model是一个Layer，而不是一个Object，不应该把一个Layer应该做的事情交给一个Object去做。</p>

<p>最后一点，软件是会成长的，FatModel很有可能随着软件的成长越来越Fat，最终难以维护。</p>

<h5 id="瘦model-slim-model">瘦Model(Slim Model)</h5>

<p>瘦Model只负责业务数据的表达，所有业务无论强弱一律扔到Controller。</p>

<p>瘦Model要达到的目的是，尽一切可能去编写细粒度Model，然后配套各种helper类或方法来对弱业务做抽象，强业务依旧交给Controller。</p>

<p>由于SlimModel跟业务完全无关，它的数据可以交给任何一个能处理它数据的Helper或其他的对象，来完成业务。在代码迁移的时候独立性很强，很少会出现拔出萝卜带出泥的情况。</p>

<p>另外，由于SlimModel只是数据表达，对它进行维护基本上是0成本，软件膨胀得再厉害，SlimModel也不会大到哪儿去。</p>

<p>缺点就在于，Helper这种做法也不见得很好，这里有一篇文章批判了这个事情。</p>

<p>另外，由于Model的操作会出现在各种地方，SlimModel在一定程度上违背了DRY（Don’t Repeat Yourself）的思路，Controller仍然不可避免在一定程度上出现代码膨胀。</p>

<h2 id="三-mvp">(三) MVP</h2>

<p><img src="https://raw.githubusercontent.com/OComme/OComme.github.io/master/Assets/Basic%20architecture/image3.png" alt="" /></p>

<p>这看起来不正是苹果所提出的MVC方案吗？</p>

<p>确实是的，这种模式的名字叫做MVC。</p>

<p>但是，这就是说苹果的MVC实际上就是MVP了？不，并不是这样的。</p>

<p>如果你仔细回忆一下，View是和Controller紧密耦合的，但是MVP的协调器Presenter并没有对ViewController的生命周期做任何改变。</p>

<p>因此View可以很容易的被模拟出来。在Presenter中根本没有和布局有关的代码，但是它却负责更新View的数据和状态。</p>

<h3 id="mvp如何分工">MVP如何分工</h3>

<p>MVP是第一个如何协调整合三个实际上分离的层次的架构模式，既然我们不希望View涉及到Model，那么在显示的View Controller（其实就是View）中处理这种协调的逻辑就是不正确的。</p>

<p>因此我们需要在其他地方来做这些事情, 比如用户输入操作, 数据请求, 数据处理等等业务逻辑。</p>

<h4 id="分工总结-2">分工总结:</h4>

<ul>
<li>视图（View）：用户界面</li>
<li>模型（Model）：数据存储</li>
<li>展示器（Presenter）：数据处理, 业务逻辑。</li>
</ul>

<p>View和Presenter之间是完全解耦的，他们通过接口来交互。</p>

<p>View和Presenter是一对一关系,意味着一个Presenter只映射一个View, 且他们之间是可以双向交互的。</p>

<h4 id="mvp-总结">MVP 总结</h4>

<p>任务均摊–我们将最主要的任务划分到Presenter和Model，而View的功能较少（虽然上述例子中Model的任务也并不多）。</p>

<p>可测试性–非常好，由于一个功能简单的View层，所以测试大多数业务逻辑也变得简单</p>

<p>易用性–在我们上边不切实际的简单的例子中，代码量是MVC模式的2倍，但同时MVP的概念却非常清晰</p>

<h2 id="四-mvvm">(四) MVVM</h2>

<blockquote>
<p>MVVM 是 MVC 模式的一种演进，它主要解决了 ViewController 过于臃肿带来的不易维护和测试的问题。其中 ViewModel 的主要职责是处理业务逻辑并提供 View 所需的数据，这样 VC 就不用关心业务，自然也就瘦了下来。ViewModel 只关心业务数据不关心 View，所以不会与 View 产生耦合，也就更方便进行单元测试。</p>
</blockquote>

<p>View 是一个壳，它所呈现的内容都需要由 ViewModel 来提供，而 View 又不与 ViewModel 直接沟通，这时就需要 ViewController 来做中间的协调者。</p>

<p>ViewController 持有 View 和 ViewModel，当 VC 初始化时，会让 ViewModel 去取数据，简单来说就是调用 VM 的某个获取数据的方法。</p>

<p>但大部分国内外资料阐述MVVM的时候都是这样排布的：</p>

<p><code>View &lt;-&gt; ViewModel &lt;-&gt; Model</code></p>

<p>造成了MVVM不需要Controller的错觉，现在似乎发展成业界开始出现MVVM是不需要Controller的的声音了。</p>

<p>其实MVVM是一定需要Controller的参与的，虽然MVVM在一定程度上弱化了Controller的存在感，并且给Controller做了减负瘦身（这也是MVVM的主要目的）。</p>

<p>但是，这并不代表MVVM中不需要Controller，MMVC和MVVM他们之间的关系应该是这样：</p>

<p><img src="https://raw.githubusercontent.com/OComme/OComme.github.io/master/Assets/Basic%20architecture/image4.gif" alt="" /></p>

<p><code>View &lt;-&gt; C &lt;-&gt; ViewModel &lt;-&gt; Model</code></p>

<p>所以使用MVVM之后，就不需要Controller的说法是不正确的。</p>

<p>严格来说MVVM其实是MVCVM。</p>

<p>从图中可以得知，Controller夹在View和ViewModel之间做的其中一个主要事情就是将View和ViewModel进行绑定。</p>

<p>在逻辑上，Controller知道应当展示哪个View，Controller也知道应当使用哪个ViewModel，然而View和ViewModel它们之间是互相不知道的，所以Controller就负责控制他们的绑定关系，所以叫Controller/控制器就是这个原因。</p>

<p>前面扯了那么多，其实归根结底就是一句话：</p>

<p>在MVC的基础上，把C拆出一个ViewModel专门负责数据处理的事情，就是MVVM。</p>

<p>然后，为了让View和ViewModel之间能够有比较松散的绑定关系，于是我们使用ReactiveCocoa，因为苹果本身并没有提供一个比较适合这种情况的绑定方法。</p>

<p>iOS领域里KVO，Notification，block，delegate和target-action都可以用来做数据通信，从而来实现绑定，但都不如ReactiveCocoa提供的RACSignal来的优雅。</p>

<p>如果不用ReactiveCocoa，绑定关系可能就做不到那么松散那么好，但并不影响它还是MVVM。</p>

<h3 id="mvvm如何分工">MVVM如何分工</h3>

<p><img src="https://raw.githubusercontent.com/OComme/OComme.github.io/master/Assets/Basic%20architecture/image5.png" alt="" /></p>

<p>其实你可以发现MVVM 与 MVP在业务逻辑上非常相似.一般情况下安卓用MVP要多一些, iOS用MVVM要多一些.</p>

<h3 id="分工总结-3">分工总结:</h3>

<ul>
<li>视图（View）：用户界面</li>
<li>模型（Model）：数据存储</li>
<li>ViewModel：数据请求, 数据处理, 业务逻辑。</li>
</ul>

<h3 id="mvvm模式特点">MVVM模式特点</h3>

<ul>
<li>MVVM将ViewController视作View</li>
<li>在View和Model之间没有紧密的联系,一般的与View是一对一的关系。</li>
<li>ViewModel与View之间是双向交互的</li>
<li>使用 MVVM 最舒服的姿势是搭配现在已经比较成熟的 ReactiveCocoa</li>
</ul>

<h3 id="mvvm-总结">MVVM 总结</h3>

<h4 id="1-任务均摊">1、任务均摊</h4>

<p>在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。</p>

<p>因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。</p>

<h4 id="2-可测试性">2、可测试性</h4>

<p>ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。</p>

<p>同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。</p>

<h4 id="3-易用性">3、易用性</h4>

<p>在我们例子中的代码量和MVP的差不多。</p>

<p>但是在实际开发中，我们必须把View中的事件指向Presenter并且手动的来更新View。</p>

<p>如果使用绑定的话，MVVM代码量将会小的多。</p>

<h2 id="五-viper">(五) VIPER</h2>

<blockquote>
<p>VIPER 是一个创建 iOS 应用简明构架的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Router) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互。</p>
</blockquote>

<h3 id="viper如何分工">VIPER如何分工</h3>

<p>当我们把VIPER和MV(X)系列作比较时，我们会在任务均摊性方面发现一些不同:</p>

<p>Model 逻辑通过把实体作为最小的数据结构转换到交互器中。</p>

<p>Controller/Presenter/ViewModel的UI展示方面的职责移到了Presenter中，但是并没有数据转换相关的操作。</p>

<p>VIPER是第一个通过路由器实现明确的地址导航模式。</p>

<p><img src="https://raw.githubusercontent.com/OComme/OComme.github.io/master/Assets/Basic%20architecture/image6.png" alt="" /></p>

<ul>
<li>视图（View）：根据展示器的要求显示界面，并将用户输入反馈给展示器。</li>
<li>交互器（Interactor）：包含由用例指定的业务逻辑。</li>
<li>展示器（Presenter）：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。</li>
<li>实体（Entity）：包含交互器要使用的基本模型对象。</li>
<li>路由（Router）：包含用来描述屏幕显示和显示顺序的导航逻辑。</li>
</ul>

<h4 id="1-交互器">1、交互器</h4>

<p>交互器在应用中代表着一个独立的用例。</p>

<p>它具有业务逻辑以操纵模型对象（实体）执行特定的任务。</p>

<p>交互器中的工作应当独立与任何用户界面。</p>

<p>由于交互器是一个 PONSO (Plain Old NSObject，普通的 NSObject)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<h4 id="2-实体">2、实体</h4>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。</p>

<p>交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。</p>

<p>如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<h4 id="3-展示器">3、展示器</h4>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。</p>

<p>基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<h4 id="4-视图">4、视图</h4>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。</p>

<p>视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。</p>

<p>展示器通过内容进行表达，而不关心那些内容所显示的样子。</p>

<p>展示器不知道 UILabel，UIButton 等的存在，它只知道其中包含的内容以及何时需要显示。</p>

<p>内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。</p>

<p>一个 UIViewController 或者它的一个子类会实现视图协议。</p>

<h4 id="5-路由">5、路由</h4>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。</p>

<p>在 VIPER 中，路由是由两个部分来负责的：</p>

<p>展示器和线框。</p>

<p>一个线框对象包括 UIWindow，UINavigationController，UIViewController 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。</p>

<p>而同时，线框知道如何进行导航。</p>

<p>在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<h3 id="viper-特点">VIPER 特点</h3>

<p>数据存储模块负责提供实体给交互器。</p>

<p>因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。</p>

<p>数据存储管理实体的持久化，而实体应该对数据库全然不知。</p>

<p>正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。</p>

<p>Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。</p>

<p>这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。</p>

<p>然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。</p>

<p>在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。</p>

<p>但是有个很恼人的地方，它会像触须一样把 NSManagedObjectContext 延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。</p>

<p>VIPER 可以使 Core Data 待在正确的地方：</p>

<p>数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，</p>

<p>其一是数据存储本身，它负责建立 Core Data 堆栈；</p>

<p>另一个是 data manager。</p>

<p>Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。</p>

<p>这样一来，应用程序核心将不再依赖于 Core Data。</p>

<p>附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<h3 id="viper-总结">VIPER 总结</h3>

<ul>
<li>任务均摊 – 毫无疑问，VIPER是任务划分中的佼佼者。</li>
<li>可测试性 – 不出意外地，更好的分布性就有更好的可测试性。</li>
<li>易用性 – 最后你可能已经猜到了维护成本方面的问题。你必须为很小功能的类写出大量的接口。</li>
</ul>

<h2 id="总结">总结</h2>

<p>这些架构模式还是要根据你的项目需求, 项目规模等条件来进行选择。</p>

<p>项目规模越小, 越简单的话, 就尽量使用最基本的MVC, 项目再复杂一些的话, 可以选择使用MVP, MVVM, 更加繁琐的项目的话, 那VIPER就可以排上用场了。</p>

<p>你会发现, 这个顺序其实是由简至繁的。</p>

<p>而为什么要做这样的选择呢?</p>

<p>因为他们都是遵循单一责任原则的, 当简单的项目繁重后, 尽量开辟出新的角色, 将其工作任务单一化。</p>

<p>这样就可以达到项目思路清晰, 易于测试, 易用性高, 维护成本低等要求了。</p>

<h1 id="我的架构思路演化">我的架构思路演化</h1>

<p>最初的时候，也是从MVC开始。</p>

<p>对与MVC的理解还很粗略：</p>

<p>M：存储数据，提供数据</p>

<p>V ：显示界面元素</p>

<p>C ：管理View Container的生命周期，负责生成所有的View实例，处理所有的业务。</p>

<p>开始开发正式的项目，便越发觉得这样的架构耦合性太高，不止开发起来很不满意，后续的维护也是异常艰难。</p>

<p>于是一遍遍的进行优化尝试，对于MVC也有了更多理解：</p>

<p>V ：显示界面元素，处理关于当前View的业务。</p>

<p>C ：管理View Container的生命周期，负责生成所有的View实例，处理View层处理不了的业务。</p>

<p>后面慢慢的又开始纠结与胖Model与瘦Model的取舍，思考如何才能将Model层优化到自己想要的，保持其使用的便利性和可拓展性。</p>

<p>尝试着使用Model层的包装以求达到两全其美，但也总感觉这样做法在某些时候有点多余。</p>

<p>在了解MVVM的基本原理及开始RAC的使用后，也开始将MVC定向的朝MVVM的方向进化。</p>

<p>此时：</p>

<p>M   ：存储数据，提供数据</p>

<p>V    ：显示界面元素，处理关于当前View的业务。</p>

<p>C    ：管理View Container的生命周期，处理有限的业务。</p>

<p>VM：数据请求，数据处理，业务逻辑。</p>

<p>再后来，开始了解其它仍未了解过的框架，基于多种框架的原理，开始优化使用中的MVVM：</p>

<p>C    ：管理View Container的生命周期，其它方面弱化为View。</p>

<p>VM：数据请求，数据处理，业务逻辑，包含为显示做的准备工作的相关视图（tableView、collectionView代理）逻辑。</p>

<p>依据VIPER，在VM层内部将其业务剥离为：</p>

<p>Interactor：处理业务逻辑。</p>

<p>Presenter ：为显示（从交互器接受的内容）做的准备工作的相关视图逻辑。</p>

<p>Entity       ：包含交互器要使用的基本模型对象。</p>

<p>架构存在于程序开发的始终，需要不断优化更新。</p>

<p><span style='color:red;font-Size:30px'>未完待续</span></p>

<p>References:</p>

<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html">iOS应用架构谈 开篇</a></p>

<p><a href="http://blog.csdn.net/wangyanchang21/article/details/52050102">iOS架构模式(MVC/MVCS/MVP/MVVM/VIPER) </a></p>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/OComme">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2017 <i class="fa fa-heart" aria-hidden="true"></i> OComme
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://ocomme.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://ocomme.github.io/js/main.js"></script>
<script src="https://ocomme.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
